mc_2 <- Mclust(data, G = 3)
plot(mc_2)
#Om vi VET att vi har 2 distributioner kan vi tvinga på G = 2
mc_2 <- Mclust(data, G = 3)
plot(mc_2)
print(summary(mc_2)$variance)
ggpairs(data)
data <- as_tibble(read.csv("faithful.csv"))
print(data)
#Tillagt för att trimma av första columnen!
data <- data[, 2:3]
print(data)
#Empirisk densitet, behöver inte ha något att göra med eventuella
#gaussiska distributioner
ggplot(data, aes(eruptions, waiting)) + geom_point()# + geom_density2d(adjust = 0.3)
#generate two circles
library(ggplot2)
library(dplyr)
library(tidyverse)
library(e1071)
#Generera data, sätt upp intervall med mera
nr_of_samples <- 2740
xmin = 2
xmax = 6
ymin = 4
ymax = 8
x_vals <- runif(nr_of_samples, min = xmin, max = xmax)
y_vals <- runif(nr_of_samples, min = ymin, max = ymax)
data <- cbind(x_vals, y_vals)
data <- as_tibble(as.data.frame(data))
print(data)
data_outside <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 < 1.6^2)
#Assigna labels och merga
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
#Gör om till factors för att få schyssta labels
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color = label))
sc
#generate two circles
library(ggplot2)
library(dplyr)
library(tidyverse)
library(e1071)
#Generera data, sätt upp intervall med mera
nr_of_samples <- 2740
xmin = 2
xmax = 6
ymin = 4
ymax = 8
x_vals <- runif(nr_of_samples, min = xmin, max = xmax)
y_vals <- runif(nr_of_samples, min = ymin, max = ymax)
data <- cbind(x_vals, y_vals)
data <- as_tibble(as.data.frame(data))
print(data)
data_outside <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 < 1.6^2)
#Assigna labels och merga
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
#Gör om till factors för att få schyssta labels
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color = label))
sc
#Vi gör en spännande support vector machine fit på det!
#Vi kan kalla på svm-paketet
svmfit = svm(label ~ x_vals + y_vals, data = all_data,
kernel = "radial", cost = 1000, scale = FALSE)
plot(svmfit, all_data)
print(svmfit)
#Centrerar - visar också vad som händer om vi inte gör det
all_data <- all_data %>% mutate(radius = sqrt((x_vals-mean(x_vals))^2
+ (y_vals-mean(y_vals))^2),angle = atan2((y_vals - mean(all_data$y_vals)),
(x_vals- mean(all_data$x_vals))))
all_data <- all_data %>% mutate(radius = sqrt((x_vals)^2
+ (y_vals-mean(y_vals))^2),angle = atan2((y_vals - mean(all_data$y_vals)),
(x_vals- mean(all_data$x_vals))))
print(all_data)
sc <- ggplot(all_data, aes(radius, angle)) + geom_point(aes(color = label))
sc
all_data$x_vals <- NULL
all_data$y_vals <- NULL
svmfit = svm(label ~ angle + radius, data = all_data,
kernel = "linear", cost = 1000, scale = FALSE)
print(svmfit)
print(all_data)
plot(svmfit, all_data)
#generate two circles
library(ggplot2)
library(dplyr)
library(tidyverse)
library(e1071)
#Generera data, sätt upp intervall med mera
nr_of_samples <- 2740
xmin = 2
xmax = 6
ymin = 4
ymax = 8
x_vals <- runif(nr_of_samples, min = xmin, max = xmax)
y_vals <- runif(nr_of_samples, min = ymin, max = ymax)
data <- cbind(x_vals, y_vals)
data <- as_tibble(as.data.frame(data))
print(data)
data_outside <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 < 1.6^2)
#Assigna labels och merga
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
#Gör om till factors för att få schyssta labels
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color = label))
sc
#Vi gör en spännande support vector machine fit på det!
#Vi kan kalla på svm-paketet
svmfit = svm(label ~ x_vals + y_vals, data = all_data,
kernel = "radial", cost = 1000, scale = FALSE)
plot(svmfit, all_data)
print(svmfit)
#Centrerar - visar också vad som händer om vi inte gör det
all_data <- all_data %>% mutate(radius = sqrt((x_vals-mean(x_vals))^2
+ (y_vals-mean(y_vals))^2),angle = atan2((y_vals - mean(all_data$y_vals)),
(x_vals- mean(all_data$x_vals))))
print(all_data)
sc <- ggplot(all_data, aes(radius, angle)) + geom_point(aes(color = label))
sc
all_data$x_vals <- NULL
all_data$y_vals <- NULL
svmfit = svm(label ~ angle + radius, data = all_data,
kernel = "linear", cost = 1000, scale = FALSE)
print(svmfit)
print(all_data)
plot(svmfit, all_data)
plot(svmfit, all_data)
#Centrerar - visar också vad som händer om vi inte gör det
all_data <- all_data %>% mutate(radius = sqrt((x_vals-mean(x_vals))^2
+ (y_vals-mean(y_vals))^2),angle = atan2((y_vals - mean(all_data$y_vals)),
(x_vals- mean(all_data$x_vals))))
#Generera data, sätt upp intervall med mera
nr_of_samples <- 2740
xmin = 2
xmax = 6
ymin = 4
ymax = 8
x_vals <- runif(nr_of_samples, min = xmin, max = xmax)
y_vals <- runif(nr_of_samples, min = ymin, max = ymax)
data <- cbind(x_vals, y_vals)
data <- as_tibble(as.data.frame(data))
print(data)
data_outside <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 < 1.6^2)
#Assigna labels och merga
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
#Gör om till factors för att få schyssta labels
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color = label))
sc
#generate two circles
library(ggplot2)
library(dplyr)
library(tidyverse)
library(e1071)
#Generera data, sätt upp intervall med mera
nr_of_samples <- 2740
xmin = 2
xmax = 6
ymin = 4
ymax = 8
x_vals <- runif(nr_of_samples, min = xmin, max = xmax)
y_vals <- runif(nr_of_samples, min = ymin, max = ymax)
data <- cbind(x_vals, y_vals)
data <- as_tibble(as.data.frame(data))
print(data)
data_outside <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 < 1.6^2)
#Assigna labels och merga
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
#Gör om till factors för att få schyssta labels
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color = label))
sc
library(tidyverse)
library(dplyr)
library(ggplot2)
library(mclust)
library(factoextra)
setwd("~/GitHub/visuell_data_analys/Lecture08")
data <- as_tibble(read_csv('faithful.csv'))
print(data)
data <- data[, 2:3]
head(data)
ggplot(data, aes(eruptions, waiting)) + geom_point()
ggplot(data, aes(eruptions, waiting)) + geom_points()
ggplot(data, aes(eruptions, waiting)) + geom_point()
dev.off()
ggplot(data, aes(eruptions, waiting)) + geom_point()
#Gaussian mixture model
dens <- densityMclust(data)
plot(dens)
plot(dens)
ggplot(data, aes(eruptions, waiting)) + geom_point()
plot(dens)
# BIC score så hög som möjligt
plot(dens, what='density', type='persp')
mc <- Mclust(data)
plot(mc)
str(summary(mc))
summary(mc)
summary(mc)$mean
summary(mc)$variance
fviz_mclust_bic(mc)
fviz_mclust_bic(mc)
ggplot(data, aes(eruptions, waiting)) + geom_point()
ggpairs(data)
data <- as_tibble(read_csv('faithful.csv'))
print(data)
data <- data[, 2:3]
ggpairs(data)
detach("package:GGally", unload = TRUE)
library(ggplot2)
library(GGally)
setwd("~/GitHub/visuell_data_analys/Lecture08")
library(tidyverse)
library(dplyr)
library(ggplot2)
library(e1071)
nr_of_samples <- 2740
xmin <- 2
xmax <- 6
ymin <- 4
ymax <- 8
x_vals <- runif(nr_of_samples, min=xmin, max = xmax)
y_vals <- runif(nr_of_samples, min=ymin, max = ymax)
data <- cbind(x_vals, y_vals)
data <- as_tibble(data)
View(data)
View(data)
data_outside <- data %>% filter((x_vals - mean(x_vals))^2 +
(y_vals - mean(y_vals))^2 > 1.8^2)
data_outside$label <- 1
data_within$label <- 0
data_outside <- data %>% filter((x_vals - mean(x_vals))^2 +
(y_vals - mean(y_vals))^2 > 1.8^2)
all_data <- rbind(data_outside, data_within)
nr_of_samples <- 2740
xmin <- 2
xmax <- 6
ymin <- 4
ymax <- 8
x_vals <- runif(nr_of_samples, min=xmin, max = xmax)
y_vals <- runif(nr_of_samples, min=ymin, max = ymax)
data <- cbind(x_vals, y_vals)
data <- as_tibble(data)
data_outside <- data %>% filter((x_vals - mean(x_vals))^2 +
(y_vals - mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals - mean(x_vals))^2 +
(y_vals - mean(y_vals))^2 < 1.6^2)
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
View(all_data)
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point()
sc
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color=label))
sc
svmfit <- svm(label ~ x_vals + y_vals, data = all_data,
kernel= 'linear', cost=1000, scale = FALSE)
plot(svmfit, all_data)
svmfit <- svm(label ~ x_vals + y_vals, data = all_data,
kernel= 'radial', cost=1000, scale = FALSE)
plot(svmfit, all_data)
plot(svmfit)
plot(svmfit, all_data)
svmfit <- svm(label ~ x_vals + y_vals, data = all_data,
kernel= 'linear', cost=1000, scale = FALSE)
plot(svmfit, all_data)
svmfit <- svm(label ~ x_vals + y_vals, data = all_data,
kernel= 'radial', cost=1000, scale = FALSE)
plot(svmfit, all_data)
print(svmfit)
print(str(svmfit)
print(str(svmfit))
str(svmfit)
svmfit$SV
sv <- svmfit$SV
#generate two circles
library(ggplot2)
library(dplyr)
library(tidyverse)
library(e1071)
#Generera data, sätt upp intervall med mera
nr_of_samples <- 2740
xmin = 2
xmax = 6
ymin = 4
ymax = 8
x_vals <- runif(nr_of_samples, min = xmin, max = xmax)
y_vals <- runif(nr_of_samples, min = ymin, max = ymax)
data <- cbind(x_vals, y_vals)
data <- as_tibble(as.data.frame(data))
print(data)
data_outside <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 < 1.6^2)
#Assigna labels och merga
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
#Gör om till factors för att få schyssta labels
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color = label))
sc
#Vi gör en spännande support vector machine fit på det!
#Vi kan kalla på svm-paketet
svmfit = svm(label ~ x_vals + y_vals, data = all_data,
kernel = "radial", cost = 1000, scale = FALSE)
plot(svmfit, all_data)
print(svmfit)
#Centrerar - visar också vad som händer om vi inte gör det
all_data <- all_data %>% mutate(radius = sqrt((x_vals-mean(x_vals))^2
+ (y_vals-mean(y_vals))^2),angle = atan2((y_vals - mean(all_data$y_vals)),
(x_vals- mean(all_data$x_vals))))
print(all_data)
sc <- ggplot(all_data, aes(radius, angle)) + geom_point(aes(color = label))
sc
all_data$x_vals <- NULL
all_data$y_vals <- NULL
svmfit = svm(label ~ angle + radius, data = all_data,
kernel = "linear", cost = 1000, scale = FALSE)
print(svmfit)
print(all_data)
plot(svmfit, all_data)
data <- cbind(x_vals, y_vals)
data <- as_tibble(as.data.frame(data))
print(data)
data_outside <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 < 1.6^2)
#Assigna labels och merga
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
#Gör om till factors för att få schyssta labels
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color = label))
sc
#Vi gör en spännande support vector machine fit på det!
#Vi kan kalla på svm-paketet
svmfit = svm(label ~ x_vals + y_vals, data = all_data,
kernel = "radial", cost = 1000, scale = FALSE)
plot(svmfit, all_data)
print(svmfit)
#Centrerar - visar också vad som händer om vi inte gör det
all_data <- all_data %>% mutate(radius = sqrt((x_vals-mean(x_vals))^2
+ (y_vals-mean(y_vals))^2),angle = atan2((y_vals - mean(all_data$y_vals)),
(x_vals- mean(all_data$x_vals))))
View(all_data)
View(all_data)
print(all_data)
sc <- ggplot(all_data, aes(radius, angle)) + geom_point(aes(color = label))
sc
svmfit = svm(label ~ angle + radius, data = all_data,
kernel = "linear", cost = 1000, scale = FALSE)
print(svmfit)
print(all_data)
plot(svmfit, all_data)
all_data$x_vals <- NULL
all_data$y_vals <- NULL
plot(svmfit, all_data)
data <- cbind(x_vals, y_vals)
data <- as_tibble(data)
data_outside <- data %>% filter((x_vals - mean(x_vals))^2 +
(y_vals - mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals - mean(x_vals))^2 +
(y_vals - mean(y_vals))^2 < 1.6^2)
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color=label))
sc
svmfit <- svm(label ~ x_vals + y_vals, data = all_data,
kernel= 'radial', cost=1000, scale = FALSE)
plot(svmfit, all_data)
str(svmfit)
sv <- svmfit$SV
points(all_data[svmfit$SV,], col = 'blue', cex = 3)
View(sv)
points(all_data[svmfit$index,], col = 'blue', cex = 3)
svmfit$index
#Centrerar - visar också vad som händer om vi inte gör det
all_data <- all_data %>% mutate(radius = sqrt((x_vals-mean(x_vals))^2
+ (y_vals-mean(y_vals))^2),angle = atan2((y_vals - mean(all_data$y_vals)),
(x_vals- mean(all_data$x_vals))))
print(all_data)
sc <- ggplot(all_data, aes(radius, angle)) + geom_point(aes(color = label))
sc
svmfit = svm(label ~ angle + radius, data = all_data,
kernel = "linear", cost = 1000, scale = FALSE)
print(svmfit)
all_data$x_vals <- NULL
all_data$y_vals <- NULL
plot(svmfit, all_data)
points(all_data[svmfit$index,], col = 'blue', cex = 3)
all_data[svmfit$index,]
all_data[svmfit$SV,]
points(svmfit$SV, col = 'blue', cex = 3)
nr_of_samples <- 2740
xmin <- 2
xmax <- 6
ymin <- 4
ymax <- 8
x_vals <- runif(nr_of_samples, min=xmin, max = xmax)
y_vals <- runif(nr_of_samples, min=ymin, max = ymax)
data <- cbind(x_vals, y_vals)
data <- as_tibble(data)
data_outside <- data %>% filter((x_vals - mean(x_vals))^2 +
(y_vals - mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals - mean(x_vals))^2 +
(y_vals - mean(y_vals))^2 < 1.6^2)
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color=label))
sc
svmfit <- svm(label ~ x_vals + y_vals, data = all_data,
kernel= 'radial', cost=1000, scale = FALSE)
plot(svmfit, all_data)
str(svmfit)
sv <- svmfit$SV
points(svmfit$SV, col = 'blue', cex = 3)
svmfit$index
svmfit$SV
#Generera data, sätt upp intervall med mera
nr_of_samples <- 2740
xmin = 2
xmax = 6
ymin = 4
ymax = 8
x_vals <- runif(nr_of_samples, min = xmin, max = xmax)
y_vals <- runif(nr_of_samples, min = ymin, max = ymax)
data <- cbind(x_vals, y_vals)
data <- as_tibble(as.data.frame(data))
print(data)
data_outside <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 > 1.8^2)
data_within <- data %>% filter((x_vals-mean(x_vals))^2 +
(y_vals-mean(y_vals))^2 < 1.6^2)
#Assigna labels och merga
data_outside$label <- 1
data_within$label <- 0
all_data <- rbind(data_outside, data_within)
#Gör om till factors för att få schyssta labels
all_data$label <- factor(all_data$label)
sc <- ggplot(all_data, aes(x_vals, y_vals)) + geom_point(aes(color = label))
sc
#Vi gör en spännande support vector machine fit på det!
#Vi kan kalla på svm-paketet
svmfit = svm(label ~ x_vals + y_vals, data = all_data,
kernel = "radial", cost = 1000, scale = FALSE)
plot(svmfit, all_data)
print(svmfit)
#Centrerar - visar också vad som händer om vi inte gör det
all_data <- all_data %>% mutate(radius = sqrt((x_vals-mean(x_vals))^2
+ (y_vals-mean(y_vals))^2),angle = atan2((y_vals - mean(all_data$y_vals)),
(x_vals- mean(all_data$x_vals))))
print(all_data)
sc <- ggplot(all_data, aes(radius, angle)) + geom_point(aes(color = label))
sc
svmfit = svm(label ~ angle + radius, data = all_data,
kernel = "linear", cost = 1000, scale = FALSE)
print(svmfit)
all_data$x_vals <- NULL
all_data$y_vals <- NULL
plot(svmfit, all_data)
points(all_data[svmfit$index,], col = 'blue', cex = 3)
svmfit$SV[,2]
svmfit$SV
svmfit$SV[,1]
points(svmfit$SV[,1], svmfit$SV[,2], col = 'blue', cex = 3)
points(svmfit$SV, col = 'blue', cex = 3)
plot(all_data, svmfit)
points(t(svmfit$SV), col = 'blue', cex = 3)
plot(svmfit, all_data)
points(t(svmfit$SV), col = 'blue', cex = 3)
t(svmfit$SV)
points(svmfit$SV[,2], svmfit$SV[,1], col = 'blue', cex = 3)
plot(svmfit, all_data)
points(svmfit$SV[,2], svmfit$SV[,1], col = 'blue', cex = 3)
svmfit$SV[,2],
svmfit$SV[,2]
